# 소멸자
  * C#과 C++ 둘 다 소멸자를 가지고 있지만 작동 방식과 사용법은 크게 다르다.
  * C#의 소멸자는 **가비지 컬렉션(Garbage Collection)**에 의해 관리되는 반면, C++의 소멸자는 명시적으로 호출할 수 있다.
  * **가비지 컬렉션**은 자동으로 메모리를 관리하는 시스템이다. 이는 개발자가 수동으로 메모리를 할당하고 해제하는 작업을 덜어준다.
  * 다만 이런 방식 때문에 개발자가 직접적으로 호출할 수 있는 메서드는 제한적이다.

```C++
C++ 소멸자 예제

#include <iostream>

class MyClass{
public:
  MyClass(){
    std::cout << "생성자 호출" << std::endl;
  }
  ~MyClass(){
    std::cout << "소멸자 호출" << std::endl;
  }
};

int main(){
  MyClass obj; // 스택에 할당된 객체

  MyClass* obj2 = new MyClass(); // 힙에 할당된 객체
  delete obj2; // 이렇게 delete로 사용자가 명시적으로 메모리를 해제 해줘야 한다.
}

출력 결과
생성자 호출 // MyClass obj;로 인해 스택에 MyClass 객체가 생성되고, 생성자가 호출
생성자 호출 // MyClass* obj2 = new MyClass();로 인해 힙에 MyClass 객체가 생성되고, 생성자가 호출
소멸자 호출 // delete obj2;로 인해 힙에 있는 MyClass 객체가 소멸되고, 소멸자가 호출
소멸자 호출 // main 함수가 종료되면서 스택에 있는 MyClass 객체 obj가 소멸되고, 소멸자가 호출
```
  * 이런 식으로 사용자가 소멸자를 맘대로 관리할 수 있는데 C#은 그렇지 않다.
  * 그러면 C#의 소멸자를 관리하는 방법은 어떻게 될까?

```C#
예제 코드

using System;

namespace Destrucotr
{
   class Program
   {
      class AA
      {
         public AA()
         {
             Console.WriteLine("AA 생성자 호출");
         }
      }
   }
}
