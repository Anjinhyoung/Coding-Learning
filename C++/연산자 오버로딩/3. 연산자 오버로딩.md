* Complex 클래스의 문자열을 이용해서 복소수 덧셈을 수행할 수 있는 훌륭한 기능을 추가하였습니다. 하지만 문제는 다음과 같은 문장은 실행이 될 까요?
* a = "-1.1 + i3.923" + a;
* 사실 이 문장이나, 원래의
* a = a + "-1.1 + i3.923";
* 문장이나 정확히 동일한 식입니다. 왜냐하면 + 연산자는 교환 법칙이 성립해야만 하기 때문이죠.
* 하지만 여러분도 이미 짐작하셨겠지만 전자의 경우에는 성공적으로 컴파일 되지 않습니다.
*  왜냐하면 a + "-1.1+i3.923" 의 경우 이 문장이 a.operator+("-1.1+i3.923") 으로 변환되어서 정확히 수행될 수 있지만 "-1.1 + i3.923" + a 의 경우에는
*  이 같은 변환이 불가능 하기 때문입니다.
*  그렇다면 이러한 문제를 어떻게 해결할 수 있을까요?

### 이항 연산자에 대해서 좀 더 다루기 전에 간단히 friend 키워드에 대해서 먼저 이야기 해보고자 합니다.

# friend 키워드
  * friend 키워드는 클래스 내부에서 다른 클래스나 함수들을 friend 로 정의할 수 있는데,
  * friend 로 정의된 클래스나 함수들은 원래 클래스의 private 로 정의된 변수나 함수들에 접근할 수 있습니다.
  * 아래 간단한 예시를 살펴봅시다.

```C++
class A {
 private:
  void private_func() {}
  int private_num;

  // B 는 A 의 친구!
  friend class B;

  // func 은 A 의 친구!
  friend void func();
};

class B {
 public:
  void b() {
    A a;

    // 비록 private 함수의 필드들이지만 친구이기 때문에 접근 가능하다.
    a.private_func();
    a.private_num = 2;
  }
};

void func() {
  A a;

  // 비록 private 함수의 필드들이지만 위와 마찬가지로 친구이기 때문에 접근
  // 가능하다.
  a.private_func();
  a.private_num = 2;
}

int main() {}
```
  * 그리고 컴파일도 잘 됨을 알 수 있습니다.

```C++
// B 는 A 의 친구!
friend class B;

// func 은 A 의 친구!
friend void func();
```
  * 
