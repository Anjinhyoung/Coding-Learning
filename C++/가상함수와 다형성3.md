# virtual 소멸자
  * 사실 클래스의 상속을 사용함으로써 중요하게 처리해야 되는 부분이 있습니다.
  * 상속 시에, 소멸자를 가상함수로 만들어야 합니다.

```C++




#include <iostream>

class Parent {
 public:
  Parent() { std::cout << "Parent 생성자 호출" << std::endl; }
  ~Parent() { std::cout << "Parent 소멸자 호출" << std::endl; }
};
class Child : public Parent {
 public:
  Child() : Parent() { std::cout << "Child 생성자 호출" << std::endl; }
  ~Child() { std::cout << "Child 소멸자 호출" << std::endl; }
};
int main() {
  std::cout << "--- 평범한 Child 만들었을 때 ---" << std::endl;
  { Child c; }
  std::cout << "--- Parent 포인터로 Child 가리켰을 때 ---" << std::endl;
  {
    Parent *p = new Child();
    delete p;
  }
}

출력 결과

--- 평범한 Child 만들었을 때 ---
Parent 생성자 호출
Child 생성자 호출
Child 소멸자 호출
Parent 소멸자 호출
--- Parent 포인터로 Child 가리켰을 때 ---
Parent 생성자 호출
Child 생성자 호출
Parent 소멸자 호출

```
  * 일단 평범하게 Child 객체를 만든 부분을 살펴봅시다.




```C++
std::cout << "--- 평범한 Child 만들었을 때 ---" << std::endl;
{ Child c; }
```
  * 생성자와 소멸자의 호출 순서를 살펴보자면
  * Parent 생성자 → Child 생성자 → Child 소멸자 → Parent 소멸자 순으로 호출됨을 알 수 있습니다.
  * 그런데 문제는 그 아래 Parent 포인터가 Child 객체를 가리킬 때 입니다.

```C++
std::cout << "--- Parent 포인터로 Child 가리켰을 때 ---" << std::endl;
{
  Parent *p = new Child();
  delete p;
}
```
  * delete p 를 하더라도, p 가 가리키는 것은 Parent 객체가 아닌 Child 객체 이기 때문에
  * 위에서 보통의 Child 객체가 소멸되는 것과 같은 순서로 생성자와 소멸자들이 호출되어야만 합니다. 그런데 실제로는, Child 소멸자가 호출되지 않습니다.
  * 소멸자가 호출되지 않는다면 여러가지 문제가 생길 수 있습니다.
  * 예를 들어서 Child 객체에서 메모리를 동적으로 할당하고 소멸자에서 해제하는데, 소멸자가 호출 안됬다면 메모리 누수(memory leak)가 생기겠지요.
