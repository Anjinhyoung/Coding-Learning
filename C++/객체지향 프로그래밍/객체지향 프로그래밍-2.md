# 함수의 오버로딩
```C++
#include <iostream>

void print(int x) { std::cout << "int : " << x << std::endl; }
void print(char x) { std::cout << "char : " << x << std::endl; }
void print(double x) { std::cout << "double : " << x << std::endl; }

int main() {
  int a = 1;
  char b = 'c';
  double c = 3.2f;

  print(a);
  print(b);
  print(c);

  return 0;
}

실행 결과
int : 1
char : c
double : 3.2
```
  * 일단 위 소스를 보게 된다면 이름이 print 인 함수 3 개가 정의가 되었음을 알 수 있습니다.
  * 고전적인 C 컴파일러에서는 오류가 발생했겠지만 C++ 에서는 함수의 이름이 같더라도 인자가 다르면 다른 함수 라고 판단하기 때문에 오류가 발생하지 않는 것입니다.

```C++
int a = 1;
char b = 'c';
double c = 3.2f;

print(a);
print(b);
print(c);
```
  * 여기서 한 가지 눈여겨 보아야 할 점은 a는 int, b는 char, c는 double 타입이라는 것입니다.
  * 이에 따라 각각의 타입에 맞는 함수들, 예를 들어 print(b) 는 b 가 char 이므로 char 형의 인자를 가지는 두 번째 print 가 호출 된 것입니다.
  * C 언어였을 경우 int, char, double 타입에 따라 함수의 이름을 제각각 다르게 만들어서 호출해 주어야 했던 반면에
  * C++ 에서는 컴파일러가 알아서 적합한 인자를 가지는 함수 를 찾아서 호출해 주게 됩니다.


# 함수의 오버로딩2

```C++
#include <iostream>

void print(int x) { std::cout << "int : " << x << std::endl; }
void print(double x) { std::cout << "double : " << x << std::endl; }

int main() {
  int a = 1;
  char b = 'c';
  double c = 3.2f;

  print(a);
  print(b);
  print(c);

  return 0;
}

출력 결과

int : 1
int : 99
double : 3.2
```

  * 이번에는 조금 특이한 경우입니다.
  * 함수가 2가지 밖에 없습니다. int 타입의 인자나 double 타입의 인자를 하나 받는 함수 하나 밖에 없습니다. 
  * 하지만 main 에서 각기 다른 타입의 인자들 (int, char, double) 로 print 함수를 호출하게 됩니다.
  * 물론 a 나 c 의 경우 각자 자기를 인자로 하는 정확한 함수들이 있어서 성공적으로 호출 될 수 있겠지만,
  * char 의 경우 자기와 정확히 일치하는 인자를 가지는 함수가 없기 때문에 '자신과 최대로 근접한 함수'를 찾게 됩니다.

### C++ 컴파일러 함수 오버로딩 과정
  * 1단계
    * 자신과 타입이 정확히 일치하는 함수를 찾는다.

  * 2단계
    * 정확히 일치하는 타입이 없는 경우 아래와 같은 형변환을 통해서 일치하는 함수를 찾아본다.
      * Char, unsigned char, short 는 int 로 변환된다.
      * Unsigned short 는 int 의 크기에 따라 int 혹은 unsigned int 로 변환된다.
      * Float 은 double 로 변환된다.
      * Enum 은 int 로 변환된다.

  * 3단계
    * 위와 같이 변환해도 일치하는 것이 없다면 아래의 좀더 포괄적인 형변환을 통해 일치하는 함수를 찾는다.
      * 임의의 숫자(numeric) 타입은 다른 숫자 타입으로 변환된다. (예를 들어 float -> int)
      * Enum 도 임의의 숫자 타입으로 변환된다 (예를 들어 Enum -> double)
      * 0 은 포인터 타입이나 숫자 타입으로 변환된 0 은 포인터 타입이나 숫자 타입으로 변환된다
      * 포인터는 void 포인터로 변환된다.

  * 4단계
    * 유저 정의된 타입 변환으로 일치하는 것을 찾는다

  * 만약에 컴파일러가 위 과정을 통하더라도 일치하는 함수를 찾을 수 없거나 같은 단계에서 두 개 이상이 일치하는 경우에
  * 모호하다 (ambiguous) 라고 판단해서 오류를 발생하게 됩니다.
