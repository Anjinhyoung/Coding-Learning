# 함수의 오버로딩
```C++
#include <iostream>

void print(int x) { std::cout << "int : " << x << std::endl; }
void print(char x) { std::cout << "char : " << x << std::endl; }
void print(double x) { std::cout << "double : " << x << std::endl; }

int main() {
  int a = 1;
  char b = 'c';
  double c = 3.2f;

  print(a);
  print(b);
  print(c);

  return 0;
}

실행 결과
int : 1
char : c
double : 3.2
```
  * 일단 위 소스를 보게 된다면 이름이 print 인 함수 3 개가 정의가 되었음을 알 수 있습니다.
  * 고전적인 C 컴파일러에서는 오류가 발생했겠지만 C++ 에서는 함수의 이름이 같더라도 인자가 다르면 다른 함수 라고 판단하기 때문에 오류가 발생하지 않는 것입니다.

```C++
int a = 1;
char b = 'c';
double c = 3.2f;

print(a);
print(b);
print(c);
```
  * 여기서 한 가지 눈여겨 보아야 할 점은 a는 int, b는 char, c는 double 타입이라는 것입니다.
  * 이에 따라 각각의 타입에 맞는 함수들, 예를 들어 print(b) 는 b 가 char 이므로 char 형의 인자를 가지는 두 번째 print 가 호출 된 것입니다.
  * C 언어였을 경우 int, char, double 타입에 따라 함수의 이름을 제각각 다르게 만들어서 호출해 주어야 했던 반면에
  * C++ 에서는 컴파일러가 알아서 적합한 인자를 가지는 함수 를 찾아서 호출해 주게 됩니다.


# 함수의 오버로딩2

```C++
#include <iostream>

void print(int x) { std::cout << "int : " << x << std::endl; }
void print(double x) { std::cout << "double : " << x << std::endl; }

int main() {
  int a = 1;
  char b = 'c';
  double c = 3.2f;

  print(a);
  print(b);
  print(c);

  return 0;
}

출력 결과

int : 1
int : 99
double : 3.2
```

  * 이번에는 조금 특이한 경우입니다.
  * 함수가 2가지 밖에 없습니다. int 타입의 인자나 double 타입의 인자를 하나 받는 함수 하나 밖에 없습니다. 
  * 하지만 main 에서 각기 다른 타입의 인자들 (int, char, double) 로 print 함수를 호출하게 됩니다.
  * 물론 a 나 c 의 경우 각자 자기를 인자로 하는 정확한 함수들이 있어서 성공적으로 호출 될 수 있겠지만,
  * char 의 경우 자기와 정확히 일치하는 인자를 가지는 함수가 없기 때문에 '자신과 최대로 근접한 함수'를 찾게 됩니다.
