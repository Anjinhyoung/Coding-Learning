# 산술 연산자 오버 로딩

  * C++ 에서는 사용자 정의 연산자를 사용할 수 있습니다. 어떠한 연산자들이 가능하나면
  * :: (범위 지정), . (멤버 지정), .* (멤버 포인터로 멤버 지정) 을 제외한 여러분이 상상하는 모든 연산자를 사용할 수 있다는 것입니다.
  * EX)
  * +, -, *  와 같은 산술 연산자
  * +=, -= 와 같은 축약형 연산자
  * ' >= '(  ' '   은 빼주시고 그냥 >= 라고 생각해주시면 됩니다.), == 와 같은 비교 연산자 
  * &&, || 와 같은 논리 연산자
  * -> 나 * 와 같은 멤버 선택 연산자 (여기서 * 는 역참조 연산자 입니다. 포인터에서 *p 할 때 처럼)
  * ++, -- 증감 연산자
  * [] (배열 연산자) 와 심지어 () 까지 (함수 호출 연산자)
  * 까지 모두 여러분이 직접 만들 수 있습니다.
  * 이 때 이러한 기본 연산자들을 직접 사용자가 정의하는 것을 연산자를 오버로딩(overloading) 한다고 부릅니다.
  * 같은 이름의 함수를 인자만 다르게 사용하는 것을 '함수를 오버로딩 했다' 라고 불렀던 것 처럼, 기본 연산자를 여러분이 설계한 클래스에 맞게 직접 사용하는 것을 '연산자를 오버로딩 했다' 라고 부릅니다.
  * 일단 연산자 오버로딩을 사용하기 위해서는, 다음과 같이 오버로딩을 원하는 연산자 함수를 제작하면 됩니다.

```C++
(리턴 타입) operator(연산자) (연산자가 받는 인자)
bool operator==(MyString& str);


(※ 참고적으로 위 방법 외에는 함수 이름으로 연산자를 절대 넣을 수 없습니다)
예를 들어서 우리가 == 를 오버로딩 하고 싶다면, == 연산자는 그 결과값이 언제나 bool 이고
인자로는 == 로 비교하는 것 하나만 받게 됩니다. 따라서 다음과 같이 함수를 정의하면 됩니다.


```

# 복소수 만들기

```C++
주의사항
참고로 C++ 표준 라이브러리에 std::complex 가 정의되어 있어서 굳이 여러분이 만들어서 쓸 필요는 없습니다. 복소수 클래스를 제작하는 이유는 순전히 교육용 입니다.
```

  * 복소수가 정확히 무엇인지 모르시는 분들을 위해서 간략하게 먼저 설명을 하고 가겠습니다.

  * ![image](https://github.com/Anjinhyoung/Coding-Learning/assets/117788976/f746de30-2234-49fb-8bd3-2c6763deb786)
  * 일단 실수의 제곱근에 대해서는 무엇인지 다들 아실 것이라 생각합니다. 그런데 실수의 제곱은 언제나 양수이기 때문에 위와 같이 음수의 제곱근은 실수로 표현할 수 없게 됩니다.
  * 따라서, 음수의 제곱근을 나타내기 위해서 특별한 수를 정의하였는데 이를 **허수(imaginary number)** 이라 부르며,
  * 실제로 존재하지 않는 수학적으로만 존재하는 수라고 볼 수 있습니다. 그리고 특히 -1 의 제곱근을 위의 수식 처럼 i 로 표기합니다.

  * 따라서, 이 때문에 예를 들어서 -4 의 제곱근은!
  * ![image](https://github.com/Anjinhyoung/Coding-Learning/assets/117788976/af67d08a-d2c5-4c0a-bf36-e9e495bdb00e)
  * 와 같이 생각할 수 있겠지요. 그리고 복소수는, 이 허수와 실수를 모두 포함하는 수 체계로, 허수와 실수의 합으로 표현할 수 있습니다. 다시 말해서, 임의의 복소수 z 는 다음과 같은 꼴입니다.
  * ![image](https://github.com/Anjinhyoung/Coding-Learning/assets/117788976/feaa14a7-8a00-42ce-bb6c-a899678cddd7)
  * 물론 여기서 a,b 는 모두 실수 입니다.

  *   우리가 만들고자 하는 것은 이 복소수를 나타내는 클래스를 구성하겠다는 이야기 입니다. 
  *   임의의 복소수 하나를 표현하기 위해서 두 개의 값(실수부, 허수부)이 필요하기 때문에 반드시 클래스로 구현을 해야 하겠죠. 따라서, 기본적으로 복소수 클래스 Complex 는 다음과 같이 간단하게 만들 수 있습니다.

```C++

class Complex {
 private:
  double real, img;

 public:
  Complex(double real, double img) : real(real), img(img) {}
};

```
  * 복소수는 언제나 실수부와 허수부로 나뉘어지므로, Complex 클래스 역시 실수부의 값과 허수부의 값을 나타내는 real 과 img 변수가 있습니다.
  *  여기서 문제는
  *  사칙 연산이 엄청나게 자주 쓰인다는 것입니다. 당연하게도 문자열의 덧셈 (+ 연산) 까지는 생각할 수 있었다 해도, 곱셈이나 나눗셈 연산 자체는 고려할 필요가 없는데,
  *  복소수의 경우 당연히 클래스 인터페이스 차원에서 곱셈과 나눗셈을 지원해주어야만 합니다.


    
```C++
class Complex {
 private:
  double real, img;

 public:
  Complex(double real, double img) : real(real), img(img) {}

  Complex plus(const Complex& c);
  Complex minus(const Complex& c);
  Complex times(const Complex& c);
  Complex divide(const Complex& c);
};
```
  * 이렇게 된다면 만일 int 형 변수였다면  " a + b / c + d; "
  * 로 간단하게 쓸 수 있었던 명령을 " a.plus(b.divide(c)).plus(d); "  와 같이 복잡한 함수식을 이용해서 표현해야만 합니다.
  * 이는, 가독성이 떨어질 뿐더러 위 식을 딱 보고 도대체 무슨 작업을 하려고 하는지도 쉽게 알 수 없습니다.
  * 하지만 연산자 오버로딩을 이용해서 plus 를 operator+ 로, divide 를 operator/ 로, 등등 바꿔준다면
  * 단순히 프로그래머가 " a + b/c + d; " 게 쓴다고 해도, 컴파일러가 a.operator+(b.operator/(c)).operator+(d); 로 알아서 변환시켜서 처리하기 때문에 속도나 다른 면의 어떠한 차이 없이 뛰어난 가독성과 편리함을 얻을 수 있게 됩니다.
  * 이를 바탕으로 간간히 Complex 클래스를 만들어보면


```C++

#include <iostream>

class Complex {
 private:
  double real, img;

 public:
  Complex(double real, double img) : real(real), img(img) {}
  Complex(const Complex& c) { real = c.real, img = c.img; }

  Complex operator+(const Complex& c) const;
  Complex operator-(const Complex& c) const;
  Complex operator*(const Complex& c) const;
  Complex operator/(const Complex& c) const;

  void println() { std::cout << "( " << real << " , " << img << " ) " << std::endl; }
};

Complex Complex::operator+(const Complex& c) const {
  Complex temp(real + c.real, img + c.img);
  return temp;
}
Complex Complex::operator-(const Complex& c) const {
  Complex temp(real - c.real, img - c.img);
  return temp;
}
Complex Complex::operator*(const Complex& c) const {
  Complex temp(real * c.real - img * c.img, real * c.img + img * c.real);
  return temp;
}
Complex Complex::operator/(const Complex& c) const {
  Complex temp(
    (real * c.real + img * c.img) / (c.real * c.real + c.img * c.img),
    (img * c.real - real * c.img) / (c.real * c.real + c.img * c.img));
  return temp;
}

int main() {
  Complex a(1.0, 2.0);
  Complex b(3.0, -2.0);

  Complex c = a * b;

  c.println();
}

출력 결과
( 7 , 4 ) 

```

  * 간혹가다 리턴 타입을 Complex& 아니냐고 생각하신 분들고 있습니다.

```C++
Complex& operator+(const Complex& c) {
  real += c.real;
  img += c.img;
  return *this;
}
```
  * 물론 이렇게 설계하였을 경우, Complex 를 리턴하는 연산자 함수는 값의 복사가 일어나기 때문에 속도 저하가 발생하지만
  * 위 처럼 레퍼런스를 리턴하게 되면 값의 복사 대신 레퍼런스만 복사하는 것이므로 큰 속도의 저하는 나타나지 않습니다.
  * 하지만, 위와 같이 operator+ 를 정의할 경우 다음과 같은 문장이 어떻게 처리되는지 생각해봅시다.

```C++
Complex a = b + c + b;
```
  * 아마도 위 문장을 쓴 사람 입장에서는 결과적으로 a = 2 * b + c; 를 의도하였을 것입니다.
  * 하지만, 실제로 처리되는 것을 보자면, (b.plus(c)).plus(b) 가 되는데, b.plus(c) 를 하면서 b 에는 (b + c) 가 들어가고,
  * 거기에 다시 plus(b) 를 하게 된다면 값 자체만 보자면 (b + c) + (b + c) 가 되서 (왜냐하면 현재 b 에는 b + c 가 들어가 있으니까)
  
  
  * a = 2 * b + 2 * c 가 되기 때문입니다. 이러한 문제를 막기 위해서는 반드시 사칙 연산의 경우 반드시 값을 리턴해야 만 합니다.
  * 또한 함수 내부에서 읽기만 수행되고 값이 바뀌지 않는 인자들에 대해서는 const 키워드를 붙여주는 것이 바람직합니다.
  * operator+ 의 경우, c 의 값을 읽기만 하지 c 의 값에 어떠한 변화도 주지 않으므로 const Complex& 타입으로 인자를 받았습니다.

# 대입 연산자 함수
  * 아마 Complex 클래스를 구현하면서 한 가지 빠뜨렸다고 생각하고 있는 것이 있을 것입니다. 바로, 대입 연산자 (=) 입니다.


```C++
Complex& operator=(const Complex& c);
```
  *  기본적으로 대입 연산자 함수는,기존의 사칙연산 연산자 함수르게, 자기 자신을 가리키는 레퍼런스 (Complex&) 을 리턴합니다.
  *  왜 굳이 대입 연산자가 자기 자신을 리턴해야 되냐면,
```C++
a = b = c;
```
  * 위와 같은 코드에서 b = c; 가 b 를 리턴해야지, a = b; 가 성공적으로 수행될 수 있기 때문이죠.
  * 이 때 Complex 타입을 리턴하지 않고 굳이 Complex& 타입을 리턴하냐면, 대입 연산 이후에 불필요한 복사를 방지하기 위해서 입니다.
  * 이와 같은 사실을 바탕으로 operator= 함수를 완성시켜 보면  다음과 같습니다.

```C++
Complex& Complex::operator=(const Complex& c)

{
  real = c.real;
  img = c.img;
  return *this;
}
```





  * 전체 코드는 다음과 같습니다.


```C++
#include <iostream>

class Complex {
 private:
  double real, img;

 public:
  Complex(double real, double img) : real(real), img(img) {}
  Complex(const Complex& c) { real = c.real, img = c.img; }

  Complex operator+(const Complex& c) const;
  Complex operator-(const Complex& c) const;
  Complex operator*(const Complex& c) const;
  Complex operator/(const Complex& c) const;

  Complex& operator=(const Complex& c);
  void println() { std::cout << "( " << real << " , " << img << " ) " << std::endl; }
};

Complex Complex::operator+(const Complex& c) const {
  Complex temp(real + c.real, img + c.img);
  return temp;
}
Complex Complex::operator-(const Complex& c) const {
  Complex temp(real - c.real, img - c.img);
  return temp;
}
Complex Complex::operator*(const Complex& c) const {
  Complex temp(real * c.real - img * c.img, real * c.img + img * c.real);
  return temp;
}
Complex Complex::operator/(const Complex& c) const {
  Complex temp(
    (real * c.real + img * c.img) / (c.real * c.real + c.img * c.img),
    (img * c.real - real * c.img) / (c.real * c.real + c.img * c.img));
  return temp;
}
Complex& Complex::operator=(const Complex& c) {
  real = c.real;
  img = c.img;
  return *this;
}

int main() {
  Complex a(1.0, 2.0);
  Complex b(3.0, -2.0);
  Complex c(0.0, 0.0);
  c = a * b + a / b + a + b;
  c.println();
}





출력 결과
( 10.9231 , 4.61538 ) 
```


  * 이제 대입 사칙 연산자  함수들인 +=, -= 등을 구현할 수 있습니다. 일단 = 와 마찬가지로 아래와 같이 Complex& 를 리턴하고
  * 그 내부 구현은 간단히 미리 만들어 놓은 operator+, operator- 등을 이용해서 처리하면 됩니다.




```C++
Complex& Complex::operator+=(const Complex& c) {
  (*this) = (*this) + c;
  return *this;
}
Complex& Complex::operator-=(const Complex& c) {
  (*this) = (*this) - c;
  return *this;
}
Complex& Complex::operator*=(const Complex& c) {
  (*this) = (*this) * c;
  return *this;
}
Complex& Complex::operator/=(const Complex& c) {
  (*this) = (*this) / c;
  return *this;
}
```
  * operator+= 의 경우 operator+ 와는 다르게 객체 내부의 상태를 변경하기 때문에 상수 함수로 선언할 수 없습니다.
  
  
