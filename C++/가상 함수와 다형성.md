# is '- a ' 와 ' has - a '

  * 일단 이야기를 진행하기 전에, 어떠한 경우에서 상속을 사용하는지 생각해봅시다.
  * C++ 에서 상속을 도입한 이유는 단순히 똑같은 코드를 또 쓰는 것을 막기 위한 Ctrl + C, Ctrl + V 방지용으로 위한 것이 아닙니다
  * 실제 이유는 상속이라는 기능을 통해서 객체지향프로그래밍에서 추구하는 실제 객체의 추상화를 좀 더 효과적으로 할 수 있게 되었습니다.
  * 이게 무슨 말이냐면 상속이란 것이 없던 C 언어에서는 어떠한 구조체 사이의 관계를 표현할 수 있는 방법이 없었습니다.
  * 하지만 C++ 에서 상속이란 것을 도입함으로써, 클래스 사이에 관계를 표현할 수 있게 되었는데, 예를 들어서 Manager 가 Employee 를 상속한다;
  * class Manager : public Employee 의 의미는

```C++
1. Manager 클래스는 Employee 의 모든 기능을 포함한다

2. Manager 클래스는 Employee 의 기능을 모두 수행할 수 있기 때문에 (Manager 에게는 약간 기분 나쁘겠지만) Manager 를 Employee 라고 칭해도 무방하다

3. 즉, 모든 Manager 는 Employee 이다.

4. Manager is a Employee !!
```

  * 따라서, 모든 상속 관계는 is a 관계라고 볼 수 있습니다. 당연한 점은, 이를 뒤바꾸면 성립되지 않는 다는 점입니다.
  * 즉 Manager 는 Employee 이지만 Employee 는 Manager 가 아닙니다
  * 이렇기에, Manager 를 Employee 로 부를 수 있지만, Employee 는 Manager 로 (미안하게도) 부를 수 없습니다.
  * 상속의 관계를 그림으로 나타내면
  * ![image](https://github.com/Anjinhyoung/Coding-Learning/assets/117788976/c074303e-6963-4f5d-88e6-fc98917e58a1)
  * 이런 식으로 나타낼 수 있습니다.
  * 또다는 ' is a ' 관계를 다른 사진으로는
  * ![image](https://github.com/Anjinhyoung/Coding-Learning/assets/117788976/4d5009cc-9328-4124-ba03-0c366e1d4f03)
  * 이런 식으로 나타낼 수 있습니다.
  * BankAccount (은행 계좌) 라는 클래스가 있고 Checking Account (자유롭게 입출금이 가능한 계좌지만 이자가 없다) 와 Savings Account (비교적 자유롭게 입출금이 불가능하지만, 매 달 이자가 붙음) 가 이를 상속 받고 있습니다.
  * 즉, 같은 계좌지만 기능이 약간 씩 다른 두 계좌 클래스들이 좀 더 '일반적인' BankAccount 클래스를 상속 받았지요.
  * 이를 통해서 상속의 또 하나의 중요한 특징을 알 수 있습니다. 바로 클래스가 파생되면 파생될 수 록 좀 더 특수화 **(구체화;specialize)** 된다는 의미 입니다
  * 즉, Employee 클래스가 일반적인 사원을 위한 클래스 였다면 Manager 클래스 들은 그 일반적인 사원들 중에서도 좀 더 특수한 부류의 사원들을 의미하게 됩니다.
  * 또, BankAccount 도 일반적인 은행 계좌를 위한 클래스 였다면, 이를 상속 받는 CheckingAccount, SavingsAccount 들은 좀 더 구체적인 클래스가 되지요. 반대로, 기반 클래스로 거슬러 올라가면 올라갈 수 록 좀 더 **일반화 (generalize)** 된다고 말합니다.
  * 그렇다면 모든 클래스들의 관계를 is - a 로만 표현할 수 있을까요? 당연히 그렇지 않습니다.
  * 어떤 클래스들 사이에서는 is - a 대신에 has - a 관계가 성립하기도 합니다.
  * 예를 들어서, 간단히 자동차 클래스를 생각해봅시다.
  * 자동차 클래스를 구성하기 위해서는 엔진 클래스, 브레이크 클래스, 오디오 클래스 등 수 많은 클래스들이 필요합니다.
  * 그렇다고 이들 사이에 is a 관계를 도입 할 수 없습니다. (자동차 is a 엔진? 자동차 is a 브레이크?) 그 대신, 이들 사이는 has - a 관계로 쉽게 표현할 수 있습니다.
  * 즉, 자동차는 엔진을 가진다 (자동차 has a 엔진), 자동차는 브레이크를 가진다 (자동차 has a 브레이크) 이와 같이 말이지요. 이런 has - a 관계는 우리가 흔히 해왔듯이 다음과 같이 클래스로 나타내면 됩니다
  * 또 다른 예로 바로 우리의 EmployeeList 를 들을 수 도 있습니다. EmployeeList 는 Employee 들과 has - a 관계 이지요. 따라서, 실제로 EmployeeList 클래스를 보면
```C++
class EmployeeList {
  int alloc_employee;        // 할당한 총 직원 수
  int current_employee;      // 현재 직원 수
  Employee **employee_list;  // 직원 데이터
```

  * 와 같이 Employee 를 포함하고 있음을 알 수 있습니다.

# (다시 보는) 오버라이딩
```C++
#include <iostream>
#include <string>

class Base {
  std::string s;

 public:
  Base() : s("기반") { std::cout << "기반 클래스" << std::endl; }

  void what() { std::cout << s << std::endl; }
};
class Derived : public Base {
  std::string s;

 public:
  Derived() : s("파생"), Base() { std::cout << "파생 클래스" << std::endl; }

  void what() { std::cout << s << std::endl; }
};
int main() {
  std::cout << " === 기반 클래스 생성 ===" << std::endl;
  Base p;

  p.what();

  std::cout << " === 파생 클래스 생성 ===" << std::endl;
  Derived c;

  c.what();

  return 0;
}

출력 결과

=== 기반 클래스 생성 ===
기반 클래스
기반
 === 파생 클래스 생성 ===
기반 클래스
파생 클래스
파생

```

  * 상속.md에 관해 복습 겸 다시 한 번 말씀드리자면
  * Base 에서 what 을 호출하면 당연히 Base 의 what 이 실행되어서 '기반' 라고 나오고, Base 를 상속받는 Derived 클래스에서 what 을 호출하면, Derived 의 what 이 Base 의 what 을 오버라이드 해서 Derived 의 what 이 호출되게 됩니다.
  * 이 코드를 약간 변형을 하면

```C++
#include <iostream>
#include <string>

class Base {
  std::string s;

 public:
  Base() : s("기반") { std::cout << "기반 클래스" << std::endl; }

  void what() { std::cout << s << std::endl; }
};
class Derived : public Base {
  std::string s;

 public:
  Derived() : s("파생"), Base() { std::cout << "파생 클래스" << std::endl; }

  void what() { std::cout << s << std::endl; }
};
int main() {
  Base p;
  Derived c;

  std::cout << "=== 포인터 버전 ===" << std::endl;
  Base* p_c = &c;
  p_c->what();

  return 0;
}
출력 결과

기반 클래스
기반 클래스  
파생 클래스
=== 포인터 버전 ===
기반

```
  * 이번에는 Derived 의 객체 c 를 Base 객체를 가리키는 포인터에 넣었습니다.
  * Base* p_c = &c;
  * 어떤 분들은 이와 같은 대입이 가능하냐고 물을 수 있습니다. Base 와 Derived 는 다른 클래스 이니까요
  * 하지만, 그 분들이 간과하고 있는 점은 Derived 가 Base 를 상속 받고 있다는 점입니다. 상속 받는다면 뭐죠? Derived is a Base
  * 즉 Derived 객체 c 도 어떻게 보면 Base 객체이기 때문에 Base 객체를 가리키는 포인터가 c 를 가리켜도 무방하다는 것입니다.
  * 그 대신 p_c 는 엄연한 Base 객체를 가리키는 포인터 입니다. 따라서, p_c 의 what 을 실행한다면 p_c 는 당연히
  * '아 Base 의 what 을 실행해 주어야 겠구나' 하고, Base 의 what 을 실행해서, Base 의 what 은 Base 의 s 를 출력 하게 됩니다.
  * 따라서 위 처럼 '기반' 이 출력됩니다.
  

